---
title: Client-Server-Architecture
order: 7
---

As of version 1.0 of the [timetraveller](#source-code-timetraveller) project, we have separated the two concerns of the server part:

* [timetraveller](#source-code-timetraveller) is the web server component. It requests trajectories from so called *connectors* and displays them interactively.
* [timetraveller-mongodb](#source-code-timetraveller-mongodb) is the reference implementation of a connector for [timetraveller](#source-code-timetraveller). It stores trajectories in the document-based NoSQL-database [MongoDB](http://docs.mongodb.org/manual/applications/geospatial-indexes/).

Both modules are very losely coupled: [timetraveller](#source-code-timetraveller) only provides an interface to query data based on a given bounding box and time range. Therefore for the [timetraveller](#source-code-timetraveller) instance it is not relevant where the data comes from. It is not even necessary that there is any database at all, for example with connectors that return realtime data from other sources.

As a result, everything related to data storage is completely done by the connectors, including the import from previously presented tools like [transportation](#source-code-transportation) and [zeitpunkt](#source-code-zeitpunkt).

### MongoDB as a reference connector

We have chosen [MongoDB](http://docs.mongodb.org/manual/applications/geospatial-indexes/) as a reference implementation for a connector. Because of its document-oriented data model this allows use to store any (also nested) object given along the GeoJSON LineString Feature. For example this possibility has been used to store the route name, colours and additional information of transit data generated by [transportation](#source-code-transportation) and [zeitpunkt](#source-code-zeitpunkt). The server component therefore can display the moving vehicles in their specific route colour.

Although [MongoDB](http://docs.mongodb.org/manual/applications/geospatial-indexes/) has built-in support for geospatial indexes, our experience is that simple three-dimensional documents, containing both coordinates and the time component for every point on a trajectory fit very well. MongoDB would allow us to directly query for regions that cover our given `LineString`s, but the storage of a document per point seems faster.

As mentioned before, the trajectory gets flattened to save one document per point of the following format:

	> db.positions.findOne()
	{
	  // x-coordinate
	  "x" : 10.0304153141,
	  // y-coordinate
	  "y" : 48.4343540454,
	  // timestamp
	  "d" : ISODate("2015-06-11T03:35:00Z"),
	  // reference to its trajectory
	  "t" : ObjectId("557a061e41dd8d4318389753"),
	  // own unique ID
	  "_id" : ObjectId("557a061e41dd8d4318389754")
	}

By avoiding MongoDB's built-in geospatial indexes it is possible to use the same schema for real UNIX timestamps as well as logical time; for WGS84 coordinates as well as other cartesian.

In addition to the single point documents, saved in a collection called `positions`, we also store the overall trajectories in a collection `trajectories`. So our search function has to query for points matching the bounding box first and then return their trajectories.

Although the name gives another idea, [timetraveller-mongodb](#source-code-timetraveller-mongodb) can be used without any affiliation to affiliation to [timetraveller](#source-code-timetraveller) at all. It simply provides standalone tools to import GeoJSON LineStrings into MongoDB and search for them. The losely connection to the [timetraveller](#source-code-timetraveller) module is only guaranteed by the well-defined signature of the search function `findTrajectories(query)`.

### Node.js Web Server

The [timetraveller](#source-code-timetraveller) projects allows to display multiple data sources provided by different connectors with a single server instance. It only has to be ensured that the `findTrajectories(query)` function of the connectors is accessable.

The web server is based on the following technologies:

* [node.js](http://nodejs.org/) as the server-sided JavaScript runtime.
* [Express](http://expressjs.com/) as the web application framework.

### Client Technologies

As the client side is focused on the presentation of the trajectories on a large map, no client-side JavaScript framework has been necessary. Nevertheless the following standalone libraries are used:

* [Leaflet](http://leafletjs.com/) to show and interact with OpenStreetMap maps.
* [LeafletPlayback](#additional-repositories-leafletplayback) to display GeoJSON Linestrings with time components as movable markers.
* [vis.js Timeline](http://visjs.org/docs/timeline/) to show an interactive visualisation of a timeline that allows moving forward and backwards in time.

Besides that, we implemented a client side library `Timetraveller` to provide some useful methods to interact with the interactive visualisation:

	// Jump to given date
	Timetraveller.setDate(new Date())

	// Perform data request
	Timetraveller.update()

	// Start/Stop animation
	Timetraveller.start()
	TImetraveller.stop()

	// Set speed
	Timetraveller.setSpeed(1)

	// Set speed on defined levels
	Timetraveller.nextSpeedLevel()
	Timetraveller.previousSpeedLevel()
